<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Z80 Assembly</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<script src="/cdn-cgi/apps/head/HN2yr-WjAPj_mRBhCVcOzfdQRRo.js"></script><link rel="Stylesheet" href="normal.css">
</head>
<body>
<h1>Z80 Assembly - Simple Structures</h1>
<p>You could ask why I don&rsquo;t speak about structuring the programs. The answer is that there is no structuring in assembly! The language is entirely made up of instructions, and it&rsquo;s up to you to create structuring. Such abstract structural elements as loops or subroutines are not provided by the language; you have to code them manually. This might sound scary, but it&rsquo;s quite easy to get used to. Moreover, this is a very powerful feature, since it gives you the complete freedom of creation.</p>
<h2>Working with arrays</h2>
<p>Arrays provide a good opportunity to demonstrate this process in an example. Let&rsquo;s make a routine that creates an array of ten elements containing the even integers from 2 to 20. There will be lots of new concepts to explain.</p>
<pre>MakeArray:                       ; this is the label indicating the beginning of the routine
  ld a,2                         ; A holds the value of the first element
  ld b,10                        ; B is the number of times we want our loop to execute
  ld hl,Numbers                  ; HL now holds the address of the first element
ArrayLoop:                       ; the label marking the beginning of the loop
  ld (hl),a                      ; storing the current element at its proper place
  inc hl                         ; increasing HL by 1, so that it points to the next element
  add a,2                        ; increasing A by 2, giving the value of the next element
  djnz ArrayLoop                 ; the end of the loop; this instruction decreases B, checks
                                 ; if it is zero, and jumps to the label given if it isn&rsquo;t;
                                 ; when B is zero, execution continues after DJNZ
  ret                            ; returning from the subroutine; explained a bit later

Numbers:                         ; this is the label that identifies our array
  .byte 0,0,0,0,0,0,0,0,0,0      ; initially the array will be full of zeroes

OtherStuff:                      ; just some kind of other data not used now
  .byte 100                      ; this is the byte that immediately follows our array</pre>
<p>Let&rsquo;s go through the code step by step. The three <code>ld</code>&rsquo;s at the beginning are the initial values of the loop. Keep in mind that <var>Numbers</var> is just a memory address for the computer, i. e. an ordinary 16-bit integer. The same goes with <var>ArrayLoop</var>, but it is of course a different address. It is very important to note: assembly does NOT distinguish between variable names and labels that mark certain parts of the code. They are all the same kind of stuff. You could use <var>ArrayLoop</var> as a variable as well, but then you would overwrite the instructions of the loop. (This is actually an advanced programming technique called Self Modifying Code or SMC, but it is too early for you to talk about at this point.) Be aware that the computer cannot distinguish between data and code, because both are just bunches of bits. It is easy to screw things up if you are not careful enough. This is one of the reasons why you should first test your code on an emulator.</p>
<p>Okay, that said, I would go on discussing the loop itself. The first instruction after the label is <code>ld (hl),a</code>, which copies the value of <tt>A</tt> into the byte pointed by <tt>HL</tt>, as we already know. When the program first enters the loop, <tt>A</tt> contains 2, the value of the first element we want to set, and <tt>HL</tt> points to the first element. So this instruction loads the proper value into the element. After this, you can see <code>inc hl</code>. This instruction advances <tt>HL</tt> by 1, so that it will point to the next element to be processed. Then we have <code>add a,2</code> that calculates the value to be put into the next element. The most important instruction this time is <code>djnz</code>. It always works with register <tt>B</tt>, that&rsquo;s just one special register role I was talking about in the <a href="part1.htm#registers">Registers</a> section. <code>djnz</code> is very useful to create loops, but it is essential to memorise that it is not a &ldquo;loop instruction&rdquo;, as such things don&rsquo;t exist in assembly. It is however a built-in conditional branch instruction that first decrements <tt>B</tt> by one, then it jumps to the address given if the result is <i>not</i> zero. If <tt>B</tt> is zero when the instruction is executed, it will overflow and take the value of 255, and since this is not zero, the jump will be taken. If I had written 0 instead of 10, the core of the loop would have been executed 256 times for this reason. To sum up, <code>djnz</code> is equivalent to &ldquo;jump if <tt>B</tt> is not equal to one or continue if it is, and decrease it anyway&rdquo;.</p>
<p>After the loop, what do we have in the registers? <tt>B</tt> will be zero, as this is the condition of leaving the loop. <tt>A</tt> will hold 22, which would be the value of the 11th element of the array, if there was such a thing. <tt>HL</tt> also points to this virtual 11th element, which is actually the same as <var>OtherStuff</var>. If we were to do an <code>ld c,(hl)</code> for instance, <tt>C</tt> would take the value of 100. Note that we have easily entered the area of another variable, and if I had loaded 11 into <tt>B</tt> initially, this byte would also have been overwritten. This is just another source of error: there is nothing to prevent you from corrupting other variables. <i>The price of freedom is responsibility.</i> Take that seriously.</p>
<p>Forget <code>ret</code> for a while, I will get back to it later.</p>
<h2><a name="branches"></a>Conditional branches</h2>
<p>Most of the programs do not simply consist of a series of instructions that are consecutively executed, but there are many places where you need to decide which way to take. This is where the flags register comes into sight. Just as always, we will look at a simple example (actually the loop above is already one). We have a signed number in <tt>A</tt>. We want to take its absolute value and write it back into <tt>A</tt>. Let&rsquo;s start with the code:</p>
<pre>  cp $80                         ; comparing the unsigned A to 128
  jr c,A_Is_Positive             ; if it is less, then jump to the label given
  neg                            ; multiplying A by -1
A_Is_Positive:                   ; after this label, A is between 0 and 128</pre>
<p>To take the absolute value, we first have to find out whether the number is negative or not. If it is, then it must be multiplied by -1. The first instruction does this with a little trick. As we know, all negative numbers in binary representation start with 1. In other words, if we consider them to be unsigned integers, they are all greater than 127. The <code>cp</code> instruction does the following thing: it subtracts the value of the operand &ndash; either a 8-bit constant, a 8-bit register or <tt>(HL)</tt>, <tt>(IX+n)</tt>, <tt>(IY+n)</tt> &ndash; from <tt>A</tt>, but does not write the result anywhere. However, it modifies the flags register (<tt>F</tt>). If the virtual subtraction results in zero, i. e. <tt>A</tt> is equal to the operand given, the <kbd>Z</kbd> (zero) flag is set. If <tt>A</tt> is less than the operand, the subtraction results in a step over zero, i. e. the <kbd>C</kbd> (carry) is set. If <tt>A</tt> is greater, then both <kbd>C</kbd> and <kbd>Z</kbd> are reset (set to zero). For these relations, both numbers are considered as <i>unsigned</i> integers.</p>
<p>In the end, if <tt>A</tt> is negative upon entering the piece of code above, the <code>cp</code> instruction sets the carry flag. The next one, <code>jr</code> is a jump instruction. It can have either one or two operands. If there is only one operand, then it is a label, and the program jumps to this label when the instruction is executed. However, in our case there are two operands. The first is always the condition, and the second is the label to jump to if the condition is met. This time the jump will be taken if the carry flag is set. All the possible conditions are listed in the next section.</p>
<p><code>neg</code> is an instruction that negates the value of <tt>A</tt>. Note that -128=128 when 8 bits are used to represent a number.</p>
<h2><a name="jumps"></a>Relative and absolute jumps</h2>
<p>You could see a jump instruction in the previous example, so it&rsquo;s time to look at them more closely. The fact whether a jump is absolute or relative depends on how you calculate the address of the destination. In the case of absolute jumps (<code>jp</code> instruction), address is always given with respect to the beginning of the memory, while the relative jumps (<code>jr</code>) only know where to jump with respect to themselves. It is easier to list the differences between the two in a table.</p>
<table border="1" cellspacing="0" cellpadding="2" align="center">
<tr><th>Property</th><th>Absolute</th><th>Relative</th></tr>
<tr><td><p align="center">Instruction</p></td><td><p align="center">jp</p></td><td><p align="center">jr</p></td></tr>
<tr><td><p align="center">Length of address</p></td><td><p align="center">16 bits</p></td><td><p align="center">8 bits</p></td></tr>
<tr><td><p align="center">Length of instruction</p></td><td><p align="center">3 bytes</p></td><td><p align="center">2 bytes</p></td></tr>
<tr><td><p align="center">Speed of execution</p></td><td><p align="center">faster</p></td><td><p align="center">slower</p></td></tr>
<tr><td><p align="center">Possible destination</p></td><td><p align="center">anywhere</p></td><td><p align="center">the vicinity (+/- 128 bytes)<br>of the jump instruction</p></td></tr>
<tr><td><p align="center">Possible conditions</p></td><td><p align="center">c, nc, z, nz, pe, po, m, p</p></td><td><p align="center">c, nc, z, nz</p></td></tr>
</table>
<p>Both kinds of jumps can be either conditional or unconditional, and the conditions work the same way. They can be one of the following: <code>c</code> (<kbd>C</kbd> flag set), <code>nc</code> (<kbd>C</kbd> flag reset), <code>z</code> (<kbd>Z</kbd> set), <code>nz</code> (<kbd>Z</kbd> reset), and only in the case of absolute jumps: <code>pe</code> (<kbd>P</kbd> set), <code>po</code> (<kbd>P</kbd> reset), <code>m</code> (<kbd>S</kbd> set) or <code>p</code> (<kbd>S</kbd> reset). At this point I think I should mention <code>djnz Label</code> again, because as we already know how it works, we can see that it is equivalent to:</p>
<pre>  dec b                          ; decrementing B by 1
  jr nz,Label                    ; if it did not become zero, jump to Label</pre>
<p>This pair of instructions and <code>djnz</code> are actually interchangeable; the only differences are that <code>djnz</code> is smaller and faster, and it preserves the flags. Here you can see that the destination of <code>djnz</code> is also limited to its vicinity. Therefore, if you want to take a jump that points farther than 128 bytes (one instruction can be 1, 2, 3 or 4 bytes long), you must use a <code>jp nz</code> combined with a <code>dec b</code> instead of it. Although it is somewhat larger in size, it is almost as fast as the original <code>djnz</code>. The assembler will always tell you if a relative jump cannot be taken, because it is the one that converts the address of the label into a relative address. When such an error is generated, you have to use <code>jp</code>.</p>
<h2><a name="subroutines"></a>Subroutines</h2>
<p>Another fundamental element of programming is the use of subroutines. In assembly, they are handled by two instructions: <code>call</code> and <code>ret</code>. The former is used to enter a subroutine, and the latter for returning from the subroutine and continue where we left off. This is achieved with the help of the <i>stack</i>. That&rsquo;s why you should not play around with <tt>SP</tt>, unless you really know what you are doing. Just as with <code>djnz</code>, we can express <code>call</code> and <code>ret</code> with the help of virtual instructions we can already interpret.</p>
<p><code>Call</code> is basically a <em>push pc+3</em> followed by a <em>jp Label</em>. (The +3 is needed to jump over the <code>call</code>&mdash;always 3 bytes long&mdash;after returning.) <code>ret</code> is even simpler, it is equivalent to a <em>pop pc</em>. Of course, this decomposition is not entirely true, since every time an instruction is executed <tt>PC</tt> is altered as well. What&rsquo;s important to keep in mind that each time a <code>call</code> occurs the address of the next instruction is pushed onto the stack, and <code>ret</code> will always continue execution from the address that is stored on the top of the stack. Hopefully I have confused you enough, so here is a working example:</p>
<pre>  call MakeArray                 ; calling the subroutine presented in the first example
  ld a,(Numbers)                 ; loading the first element into A (i. e. 2)
  ld c,(hl)                      ; if everything went right, C will hold 100 after this</pre>
<p>To be short: the <code>call</code> pushes the address of the <code>ld a,(Numbers)</code> instruction on the top of the stack and jumps to <var>MakeArray</var>. <var>MakeArray</var>, as we know, fills the 10 bytes beginning at <var>Numbers</var> with the first 10 even numbers. When the program reaches the <code>ret</code> I put at the end of the subroutine, the return address will be retrieved from the stack. After returning, we continue from the address saved by <code>call</code>. As I explained above, <tt>C</tt> should be loaded with 100, because the loop in the subroutine causes <tt>HL</tt> to point at that value.</p>
<p>To ease our lives, both <code>call</code> and <code>ret</code> can be used with conditions in the very same manner as <i>absolute</i> jumps, i. e. all the eight conditions can be investigated. If you write for instance <code>call c,Label</code>, the call only occurs if the <kbd>carry</kbd> is set. Similarly, <code>ret z</code> will only return if the <kbd>zero</kbd> flag is set. This way the subroutines can be combined with conditions in a compact way.</p>
<p>Finally, here is a bit advanced example. With the help of <code>call</code>, you can also determine the value of <tt>PC</tt>:</p>
<pre>  call NextInstr                 ; calling the NEXT instruction
NextInstr:                       ; the label we jump to
  pop hl                         ; popping the address of the instruction into HL</pre>
<p>This is equivalent to the otherwise impossible <em>ld hl,pc</em>. Although there is no <code>ret</code>, the code will not cause any problem, because the only important thing, the stack is properly handled. I just showed this example to you in order to demonstrate again the freedom assembly gives to you.</p>
<p><a href="index.htm">Back to the index</a></p>
</body>
</html>
